chat application using socket communication

1. make a chat ui 
2. make a states and possible data to preserve
    
const defaultMessageBody={
    senderId:'',
    senderName:'',
    message:'',
    receiverId:'',
    receiverName:'',
    time:'',

}

  this.state = {
            msgBody:{
                ...defaultMessageBody
            }
        }
3.make handlechange and handlesubmit button 
   handleChange=e=>{
        const {name,value}=e.target
        this.setState(prevstate=>{
            return{
                msgBody:{
                    ...prevstate.msgBody,
                    [name]:value
                }
            }
        })
    }
    submit=e=>{
        e.preventDefault()
        const {msgBody}=this.state

    }

4. now on submit you need to send the massage to socket server and socket server will send back message to react/client and show
that message in ui
submit=e=>{
        e.preventDefault()
        const {msgBody}=this.state
        msgBody.senderName=this.currentuser.username; // send sendername in socket server this is we get from the logged in info/localstorage by retrieving on componentDidMount
        msgBody.time=Date.now()  //time of message send
        this.socket.emit('new-message',msgBody)

    }

     componentDidMount() {
        this.socket = io(SOCKET_URL)
        this.runSocket();
        this.currentuser=JSON.parse(localStorage.getItem('user'))
    }

make on in server and emit the samemessage from server so that client can receive that message and show in ui

 io.on('connection', function (client) {
        console.log('client connected to socket server', client.id);

        client.on('new-message',function(data){
            client.emit('reply-message-own',data)
        })
    })

see in nodejs socket.js program

now the message needs to be shown when it comes from socket server 
so the emitted message from socket server are stored in message state as an array:
add state message in this.state

message:[]

in runsocket
   runSocket = () => {
        this.socket.on('reply-message-own', (data) => {
            const { messages } = this.state
            console.log("message is", data)
            messages.push(data)
            this.setState({
                messages: messages
            })
        })
    }

show in UI 

   <main className="msger-chat">

                            {
                                this.state.messages.map((item, index) => {
                                    return (
                                        <div className="msg left-msg" index={index}>
                                            <div className="msg-img" ></div>
                                            <div className="msg-bubble" >
                                                <div className="msg-info">
                                                    <div className="msg-info-name">{item.senderName}</div>
                                                    <div className="msg-info-time">{relativeTime(item.time,"minutes")}</div>
                                                </div>

                                                <div className="msg-text">
                                                    {item.message}
                                                </div>
                                            </div>
                                        </div>

                                    )
                                })
                            }

                        </main>

the message now will be shown and the input should be empty: so in input field put name 
<input type="text" value={this.state.msgBody.message} className=" msger-input" placeholder="Enter your message..." onChange={this.handleChange} name="message"></input>

when the socket meessage from server comes and displayed in UI after submitting set the message state to ''
 submit = e => {
        e.preventDefault()
        const { msgBody } = this.state
        msgBody.senderName = this.currentuser.username;
        msgBody.time = Date.now()
        this.socket.emit('new-message', msgBody)
        this.setState({
            msgBody:{
                message:''
            }
        })

    }


5.the message is only displayed to those who is requesting that event, the message is not shown to other 
but the message needs to be shown to other people

so along with emit use broadcast in server
emit-> it is used to show the content only for requesting server
broadcast-> it is used to show the content for all other clients connected in socket server but not for the requesting client

so to show both the requesting client and requesting server use both of them
   io.on('connection', function (client) {
        console.log('client connected to socket server', client.id);

        client.on('new-message',function(data){
            client.emit('reply-message-own',data)
        })
        client.on('new-message',function(data){
            client.broadcast.emit('reply-message',data)
        })
    })

now with emit requesitng client will get the info


 and with broadcast other clients will get the information


 for this message there should be handler in react so  in runsocket
   runSocket = () => {
        this.socket.on('reply-message-own', (data) => {
            const { messages } = this.state
            console.log("message is", data)
            messages.push(data)
            this.setState({
                messages: messages
            })
        })
        this.socket.on('reply-message', (data) => {
            const { messages } = this.state
            console.log("message is", data)
            messages.push(data)
            this.setState({
                messages: messages
            })
        })
        
    }

    upperpart is only for own messsage : when emit is called this block of code will only runsocket
    for reply-message : when broadcast runs down part of code will runsocket
    so include the both block of code for group chatting
6. Private chat

you need the information of the person who are active and who are not active: 
active person: who are connected to the socket server
inactive person: who are not connected to the socket server

so from react when the person is opening react it should emit the username 
and when react emits username server should store username and its id 

to show all the users conencted server should emit all the users that are stored in array from above 2 className
and in react 'on' case it should display all users emitted from the server

 i.in react emmit
    runSocket = () => {
        this.socket.emit('new-user', this.currentUser.username)
    }
 ii. in server storer all users info 
   io.on('connection', function (client) {
        console.log('client connected to socket server', client.id);
        var id = client.id;
        client.on('new-user', function (username) {
            users.push({
                id: id,
                name: username
            })   
        }
   iii. emmit the users from server to client
   client.emit('users', users)

   complete code of server
   initialize users as array

          io.on('connection', function (client) {
        console.log('client connected to socket server', client.id);
        var id = client.id;
        client.on('new-user', function (username) {
            users.push({
                id: id,
                name: username
            })
           client.emit('users', users)
            client.broadcast.emit('users', users) 
        })

        

        client.on('new-message',function(data){
            client.emit('reply-message-own',data)
        })
        client.on('new-message',function(data){
            client.broadcast.emit('reply-message',data)
        })
    })

}

now the client  should show the information  on handling 'on' request 
     
3. show all active users
 
 make a UI for the active users and add css for it

    <h2> Active Users</h2>
                        {this.state.users.map((user, index) => (
                            <div key={index} className="msg left-msg ">
                                <div
                                    className="msg-img"
                                >
                                </div>
                                <button className="btn btn-default" onClick={() => this.selectUser(user)}>{user.name}</button>

                            </div>
                        ))}


the active users are those users who are currently connected to the socket server and from backend users are send to the front end 
and handled according to that way 

the active users are handled as 
in node js socket.js
client.on('disconnet',function(data){
            users.forEach((user,index)=>{
                if (user.id === id) {
                    users.splice(index, 1)
                }
                client.broadcast.emit('users', users)

            })
        })

loop all users present and in disconnect event: id is stored as default event for disconnection and if id is matched splice that user
and emit that user on user event 


4. Private chat with only one person 
in front end if you click the person name in active users section their name and id as a receiver should me sent to socket server
so

<button className="btn btn-default" onClick={() => this.selectUser(user)}>{user.name}</button>

in selectUser

 selectUser=user=>{
        this.setState(prevstate=>{
            return{
                msgBody:{
                    ...prevstate.msgBody,
                    receiverId:user.id,
                    receiverName:user.name,
                }
            }
        })
    }



in server node js -socket.js

client.on('new-message',function(data){
            client.broadcast.to(data.receiverId).emit('reply-message',data)
            // console.log(data.receiverid,data.receiver)
        })

now you can send message but if you haven't selected a user then still it will send message but to whom we don't know hence
if userv haven't selected any user then give user proper message "please select a user to continue"

for this in submit 

 if(!msgBody.receiverId){
            return notify.Progressnotification("please select at least a user to communicate")
        }

now if any user is not selected it will give proper msg and error

now the problem is when you send message by clicking the receiver you can send the message, but whenever you type the message from
receiver to send message to sender it will again say please select a user to continue 

for this you should send sender id as well as receiver id, and when the reply message event is triggered you exchange
receiver id as sender id and communication will go on and on 

add sender id in messagebody
 users.forEach((user, index) => {
            if (user.name === this.currentUser.username) {
                msgBody.senderId = user.id
            }
        })

and exchange the receiver id to sender id when receiver sends the message
    this.socket.on('reply-message', (data) => {
            const { messages,msgBody } = this.state
            msgBody.receiverId = data.senderId ///here it is 
            console.log("message is", data)
            messages.push(data)
            this.setState({
                messages: messages
            })
        })        







